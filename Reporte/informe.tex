\documentclass[12pt,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage[left=1.3cm,right=1.3cm,top=1.8cm,bottom=4cm]{geometry}
\usepackage{lastpage}
\usepackage{marginnote}
\usepackage{multirow}
\usepackage{wallpaper}
\usepackage{fancyhdr}
\setlength{\headheight}{87pt} 
\pagestyle{fancy}\fancyhf{}
\renewcommand{\headrulewidth}{0pt} 
\setlength{\parindent}{0cm}
\newcommand{\tab}{\hspace*{2em}}
\newcommand\BackgroundStructure{
	\setlength{\unitlength}{1mm}
	\setlength\fboxsep{0mm}
	\setlength\fboxrule{0.5mm}
	\put(10, 10){\fcolorbox{black}{white!10}{\framebox(192,247){}}}
	\put(10, 262){\fcolorbox{black}{white!10}{\framebox(192, 31){}}}
}

%-------------------------ENCABEZADO---------------
\fancyhead[L]{\begin{tabular}{l r | l r}	
		\textbf{Proyecto} & 1 & \textbf{Página} & \thepage/\pageref{LastPage} \\
		\textbf{Trabajo} & Desarrollo de un reloj en tiempo real & \textbf{Actualizado en:} & 6/11/2016 \\
		\textbf{} &  con Nexys 4 y V3023 & \textbf{Revisado en:} & 8/11/2016 \\
		\textbf{Grupo} & 8 & \textbf{Diseñadores} & Keylor Mena Venegas \\
		\textbf{Revisado por:} & Alfonso Chacón Rodríguez & \textbf{ } & Luis Leon Vega \\
		\textbf{} & & \textbf{ } & Luis Merayo Gatica
	\end{tabular}}
	
	\begin{document}
		\AddToShipoutPicture{\BackgroundStructure}
		
		\section*{\textit{Resumen}}
		
		Se debe realizar un controlador para realizar la lectura y escritura del módulo RTC V3023. Los datos del sistema deben poder ser desplegados en un monitor LCD mediante el protocolo VGA. Ante ello, se debe realizar un controlador para el RTC y para la VGA. Asimismo, se deben poder ajustar la hora, activar la alarma y el cronómetro de forma descendente mediante botones e interruptores dispuestos en la FPGA Nexys 4.\\
		
		\section*{\textit{Introduccion}} 
		Este proyecto consiste en realizar un controlador de módulos RTC (Real Time Controller), específicamente para el módulo V3023. Este controlador será capaz de escribir y leer dicho módulo para obtener parámetros de reloj, cronómetro y alarma. \\
		Asimismo, para poder desplegar la información relevante de los parámetros anteriores, se conectará un monitor LCD mediante el protocolo VGA. Por otro lado, para poder programar y dar instrucciones al circuito, se deberán usar los botones señalados en el instructivo y algunos interruptores. \\
		Finalmente, el conjunto es un circuito que permita controlar el módulo y comunicar al usuario mediante los botones y el monitor LCD, donde él podrá recibir la información relevante y poder modificar dicha información.\\
		
		\section{Objetivos}
		\begin{itemize}
			\item Diseñar un controlador de RTC que permita leerlo y programarlo mediante una interfaz de usuario consistente en botones incorporados dentro de la FPGA (Nexys 4) y un monitor comunicado a través del protocolo VGA.
			\item Investigar el funcionamiento del módulo RTC y el protocolo de comunicación del mismo.
			\item Diseñar un controlador para el módulo RTC, cuyo bus de datos y direcciones estén multiplexados.
			\item Cumplir con las reglas de temporizado del sistema, en especial, con el protocolo de comunicación del módulo RTC.
			\item Combinar el controlador de RTC con un controlador VGA para poder desplegar la información del módulo al usuario. Este módulo VGA será adaptado del proyecto anterior.
			\item Desarrollar un banco de pruebas (testbench) para poder emular el comportamiento del módulo RTC con la finalidad de comprobar el funcionamiento del circuito controlador.
		\end{itemize}
		
		\section{Descripción del sistema}
		El sistema se puede dividir en cuatro subsistemas, para facilitar el diseño dividimos el sistema en 4 grandes partes, el controlador de la pantalla, el controlador para el RTC, el control de usuario y  una memoria principal. Éstos subsistemas, pueden ser desarrollados de manera separada siempre que se tenga el cuidado necesario con los datos que comparten entre los bloques, para este efecto se desarrollo una memoria con 2 registros que se actualizan entre ellos al activar banderas. En la Fig. \ref{fig:sistema} se puede observar la composición general del sistema. \\[2ex]
		
		\begin{figure}[hbtp]
			\centering
			\includegraphics[height=8.5cm, width=18cm]{img/Subsistemas.jpg}
			\caption{Diagrama de modulos principales del sistema.}
			\label{fig:sistema}
		\end{figure}
		
		\subsection{Controlador de la pantalla}
		Para el periférico de despliegue de datos se ha solicitado emplear un monitor LCD controlado mediante el protocolo VGA (Video Graphics Array), con la finalidad de aprovechar el desarrollo del proyecto anterior y adaptando algunas cosas para poder incorporar datos dentro de la imagen que se desplegará en el monitor. Este diseño está basado en el mismo implementado para el proyecto anterior, con la salvedad de que, en este diseño, los registros no son actualizados de forma autónoma y son modificados por el microcontrolador PicoBlaze. Esto varía la salida del bus Adr en el diseño anterior y se cambia por el PortID.
		\subsubsection{Diagrama de primer nivel}  \label{sec:VGA_pn}
		Para efectos del circuito, este debe admitir datos de las variables del tiempo emitidas por el Picoblaze, que son emitidos por el PortID y el DataOUT del mismo microcontrolador. Para ello, se ha puesto un banco de 16 registros (11 aprovechados) direccionados mediante un bus de direcciones de 4 bits y 8 bits de datos. Asimismo, se deben colocar las entradas y salidas pertinentes del protocolo, que son las salidas de sincronía y las salidas de color. Asimismo, este circuito recibe la señal de IRQ procedente de la RTC para poder señalar el cúlmino de la cuenta del timer. \\[2ex]
		
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=15cm]{img/VGAPrimerNivel.png}
			\caption{Diagrama de primer nivel VGA}
			\label{fig:vgaPrimerNivel}
		\end{figure}
		
		A como es posible observar en la figura \ref{fig:vgaPrimerNivel}, existen dos buses que permiten obtener la información que será desplegada en la pantalla. El bus "PortID" permite direccionar el registro de la memoria de datos al registro que va a ser refrescado y el bus "DataIN" recopila la información del registro direccionado mediante "PortID". Esta comunicación es de solo lectura y solo será efectuada durante la sincronía vertical, que no contiene imagen para evitar glitches y cambios en el registro inesperados que vayan a afectar la nitidez de la imagen. \\[2ex]
		Asimismo, este circuito tiene un bus de salida "DataOUT" que es multiplexado hacia el Picoblaze para avisar de los períodos de sincronía vertical para poder actualizar la VGA. \\[2ex]
		Para concluir este apartado, la interfaz se definirá mediante imágenes para cargar una interfaz agradable al usuario, esto aprovechando la capacidad de síntesis de memoria ROM en el entorno de Xilinx. \\[2ex]
		
		\subsubsection{Diagrama de segundo nivel} \label{sec:VGA_sn}
		Adentrando en el diseño, se pueden identificar tres grandes bloques que componen el control de pantalla, donde es posible generar los datos, generar las señales de posición y sincronía y las señales de los colores.
		
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=18cm]{img/VGASegundoNivel.png}
			\caption{Diagrama de segundo nivel VGA}
			\label{fig:vgaSegundoNivel}
		\end{figure}
		
		Como es posible apreciar en la figura \ref{fig:vgaSegundoNivel}, el primer bloque es el de "Contadores y generadores sincronía", que permite generar las señales de sincronización del monitor LCD y, además, generar la posición de la pantalla en la que se ubica el cursor. Esto último es clave para la etapa de "Generador de datos", que decidirá los datos que serán pintados y las memorias que serán consultadas. \\[2ex]
		
		El bloque "Generador de datos" permitirá producir las señales de color primitivo (2 bits por color) de la imagen que será pintada en la pantalla con base a los datos que se registren mediante los buses "PortID" y "DataIN", cuyos datos se almacenarán en un buffer de memoria de video. Basado en los datos de este buffer, se determinará el dato que se ilustrará (número) mediante un posicionamiento en memoria. Los datos que saldrán en la dirección serán generados por un contador de 12 dígitos y su proceso de incremento estará condicionado por el VSync para poder actualizar el buffer en momentos de sincronía (Pasado hacia el microcontrolador), donde se no pintan pixeles. Por otro lado, las posiciones de memoria serán determinantes para consultar la memoria ROM que contendrá la interfaz y los números. \\[2ex]
		Por otro lado, el "Control de salida" permite decodificar el color en 2 bits en 4 bits mediante el duplicado. Asimismo, apaga los bits de salida en caso de entrar en etapa de sincronía, indicado mediante la entrada de "Blank". Esto evitará enviar datos en caso de ubicarse en un proceso de tiempo prohibido en la pantalla. \\[2ex]
		
		
		\subsubsection{Diagrama de tercer nivel}
		Profundizando aún más en el diseño, los bloques se pueden descomponer más haciendo evidente la presencia de una memoria ROM que contiene la información de la interfaz gráfica de usuario, que está subdividida en la memoria ROM de interfaz y la memoria ROM de los números, ya que todo el entorno es visual (véase figura \ref{fig:vgaTercerNivel}).\\[2ex]
		Asimismo, el generador de datos está compuesto por un direccionador de memoria mediante punteros y un banco de registros que ayudan a tener los datos estables para su uso. Dependiendo de la posición del cursor en la pantalla (CntX) y (CntY) y los datos de los registros, es posible direccionar a un campo específico de la memoria ROM de números y hacer el intercambio entre ROM de interfaz y ROM de números.\\[2ex]
		
			\begin{figure}[hbtp]
				\centering
				\includegraphics[width=18cm]{img/VGATercerNivel.png}
				\caption{Diagrama de tercer nivel VGA}
				\label{fig:vgaTercerNivel}
			\end{figure}
			\begin{figure}[hbtp]
				\centering
				\includegraphics[width=13cm]{img/VGAInterfaz.png}
				\caption{Interfaz de VGA}
				\label{fig:vgaInterfaz}
			\end{figure}
		
		Por otro lado, se encuentran los contadores y generadores de sincronía, que están compuestos por dos contadores y un bloque combinacional. El primer contador gobierna el conteo horizontal (CntX) y, a su vez, regula la velocidad de conteo descartando los 2 primeros bits menos significativos, por lo cual, el contador es de 12 bits para abarcar las 800 líneas horizontales. Este contador envía una señal de conteo al contador vertical, quien gobierna la posición vertical (CntY). El bloque combinacional permite generar las señales VSync y HSync dependiendo de la magnitud del conteo CntX y CntY, así como, la señal de Blank, donde no debe existir señal de color por encima de 0V.\\[2ex]
		El Control de salida permite, a como se explicó en el apartado anterior, expandir los bits de color para poder generar una señal de 12 bits de color. Asimismo, es gobernado por el Blank que pone en ceros todos los bits de color en tiempos de zona prohibida. \\[2ex]
		Para finalizar, las memorias tienen un dimensionamiento de 307200 espacios de memoria para albergar la interfaz de usuario (640X480) (figura \ref{fig:vgaInterfaz}) y de 24000 espacios para albergar las imágenes de los números (figura \ref{fig:vgaNumeros}). Los datos de estas memorias serán generadas por un script de Matlab y se cargarán mediante un archivo de texto con 6 bits. \\[2ex]
		
		
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=1cm]{img/VGANumeros.png}
			\caption{Números VGA}
			\label{fig:vgaNumeros}
		\end{figure}
		
		Cabe destacar que, la interfaz tiene espacios azules para indicarle al sistema de punteros cuando debe hacer cambio de imagen por un número. Esto se hizo con la finalidad de ahorrar espacio en la Nexys y optimizar el código, ya que existieron problemas debido al rendimiento en tiempo de todo el bloque VGA.\\[2ex]
		
		
		\subsection{Controlador de teclado}
		Una de las diferencias de este proyecto con respecto al anterior es la incorporación de un teclado con comunicación bajo el protocolo serial PS2. Este protocolo serial emplea un reloj generado por el periférico y una línea de datos que permite transmitir los datos en sincronía con el reloj del periférico.\\ [2ex]
		Para efectos de uso, se han tomado en cuenta las siguientes teclas para poder usar, más adelante, el circuito:
		
		\begin{table}[htb]
			\centering
			\caption{Configuración de las teclas}
			\begin{tabular}{c|c}
				Tecla & Función \\
				\hline
				\hline
				F1 & Alterar fecha \\
				F2 & Alterar hora \\
				F3 & Alterar cronómetro \\
				F10 & Apagar alerta del cronómetro \\
				F11 & Activar cronómetro \\
				F12 & Detener cronómetro \\
				Esc & Descartar y Salir \\
				Enter & Guardar y Salir \\
				Tab & Seleccionar Siguiente \\
				0-9 & Valores numéricos \\
			\end{tabular}
			\label{tab:teclas}
		\end{table}
		
		Para las salidas del circuito, este guardará los valores de la selección del usuario hasta que haya un commit = 1 y un ReadStrobe que indique que los datos fueron leídos por el microcontrolador. Asimismo, hay una salida hacia los display de 7 segmentos para comprobar los datos.
		
		\subsubsection{Diagrama de primer nivel}
		El diseño básico es presentado en la figura \ref{fig:KBPrimerNivel}, donde se indican las entradas y salidas del circuito. En estas, se presentan las direcciones del PortID procedente del Picoblaze, la salida de datos hacia el Picoblaze (DataOUT) y un indicador de lectura ReadStrobe, que permite comprobar al controlador de teclado que los datos fueron leídos y poder, así, borrar los registros del control. Por otro lado, es posible notar las entradas del teclado PS2 (PS2\_CLK y PS2\_DATA) y las salidas hacia los displays de 7 segmentos que permiten comprobar el funcionamiento del microcontrolador y del teclado.
		
		
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=14cm]{img/KBPrimerNivel.png}
			\caption{Diagrama de primer nivel KB}
			\label{fig:KBPrimerNivel}
		\end{figure}
		
		\subsubsection{Diagrama de segundo nivel}
		Para la segunda iteración del diseño, se investigó acerca del funcionamiento del teclado y un código de ejemplo para un teclado que muestra los códigos de las teclas en los display de 7 segmentos [3]. Este código estaba diseñado para una Nexys 4 DDR, que, a como fue posible notar, es ligeramente diferente a la Nexys 4 que se emplea, actualmente.\\ [2ex]
		Tomando en cuenta un diseño basado en el código de ejemplo, la iteración del diseño queda de acuerdo con la figura \ref{fig:KBSegundoNivel}.
		
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=18cm]{img/KBSegundoNivel.png}
			\caption{Diagrama de segundo nivel KB}
			\label{fig:KBSegundoNivel}
		\end{figure}
		
		Las etapas modificadas y basadas en el ejemplo son el Adaptador de señal, el Receptor PS2 y el Decodificador de 7 segmentos. La alteración de estas radica en las conexiones y el ancho de los buses de datos de I/O de cada segmento. Sin embargo, el Adaptador de señal se ha tomado intacto, ya que es esencial para el Receptor PS2 y evitar posibles rebotes causados por desconexiones o posibles fluctuaciones eléctricas. \\ [2ex]
		El Receptor PS2 permite convertir el dato recibido bajo formato serial a un formato paralelo de 32 bits (16 bits aprovechables), que permiten tener en cuenta los valores de las teclas en una forma de pila para el Control de Teclado (KeyCode). \\ [2ex]
		El Control principal se encarga de decodificar cada tecla, modificar los registros correctos y llevar en cuenta las direcciones que se van modificando bajo cada combinación en la secuencia de las teclas. Asimismo, vigila la lectura del Picoblaze para determinar cuando el dato ha salido leído y repetir una nueva rutina de lectura. Este control cuenta con 3 registros que contienen la dirección del dato que se va a alterar (si son segundos, minutos, horas...), el dato que se escribirá, gobernado principalmente por las teclas numéricas y el registro de commit, que permite guardar el dato en el Picoblaze.\\ [2ex]
		El decodificador de dirección recibe el PortID del Picoblaze y permite direccionar al multiplexor (Multiplexor de salida) en la salida de los datos hacia el mismo microcontrolador (Seleccionar entre Dirección, Dato o Commit). Asimismo, lleva en cuenta cuando el Picoblaze hace lectura del registro commit, que alerta que el Control Principal debe hacer Reset. \\ [2ex]
		Finalmente, el Decodificador de 7 segmentos es combinacional y permite decodificar los datos en Hexadecimal para proyectarlos en los displays de la placa Nexys 4.
		
		\subsubsection{Diagrama de tercer nivel}
		Para la última iteración del diseño modular del Controlador e Teclado, el diseño continúa la línea del segundo nivel, a excepción de que se hacen visibles los nombres de los registros que serán alterados por el ControlKB y serán entregados al Mux para dirigirlos al Picoblaze y el Decodificador de 7 segmentos. Además, se han colocado los nombres de los módulos como fueron implementados en HDL. Para observar el diseño, consulte la figura \ref{fig:KBTercerNivel}.
		
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=18cm]{img/KBTercerNivel.png}
			\caption{Diagrama de tercer nivel KB}
			\label{fig:KBTercerNivel}
		\end{figure}
		
		\subsection{Control de usuario}
		Para poder controlar el acceso del usuario, que se comunica por medio de 7 botones, 3 interruptores que indican que se quiere cambiar, el reloj, el timer o la alarma, y para moverse entre los registros de datos y aumentar o disminuir sus valores.\\ 
		
		\subsubsection{Diagrama de primer nivel}
		el control de usuario posee 3 interruptores y 4 botones para que el usuario elija los datos y que desea cambiar. Ademas posee entradas y salidas de memoria para poder alterar los registros y escribirlos en la rtc. Se puede notar esto en la figura \ref{fig:PrimerNivelcontrolusr}.
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[height=3cm, width=10cm]{img/nivel1_contusr.jpg}
			\caption[1erNivel]{Diagrama de primer nivel del control de usuario.}
			\label{fig:PrimerNivelcontrolusr}
		\end{figure}
		
		\subsubsection{Diagrama de segundo nivel}
		En este diagrama mostrado en la Fig. \ref{fig:SegundoNivelControlusr} se muestra como se pretende realizar el control de usuario, el cual consiste en tan solo dos bloques.\\[2ex]
		
		Consiste un un control de acceso que controla el cambio de los valores de los registros y el control de sus direcciones en el registro. El registro estará en la memoria de coneccion esta memoria controla la actualización de los registros por medio de señales de control, esta es la señal de control, con esta se controla la salida memoria in y memoria out. \\[2ex]
		
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[height=7cm, width=16cm]{img/nivel2_contusr.jpg}
			\caption[1erNivel]{Diagrama de segundo nivel del Teclado.}
			\label{fig:SegundoNivelControlusr}
		\end{figure}
		
		\subsection{Controlador del RTC}
		Para la implementación de esta interfaz que va a permitir la comunicación entre la FPGA y el RTC, se desarrolló 7 bloques principales divididos en una jerarquía de 3 niveles, se puede ver en la figura \ref{fig:Jrtc}. Existen 3 bloques principales uno de inicializacion, un while true, que permite la lectura continua de los datos de la rtc, y una de programación que permite actualizar los cambios del control de usuario.\\ [2ex]
		Ademas existen 2 bloques que permiten un bloque que permite leer y escribir datos, esta activa un control que esta basado en los tiempos de la figura \ref{fig:DTE} y la figura \ref{fig:DTL}, como se puede notar existen muchas similitudes entre ambos ciclos, para esto llamaremos a esta diferencia "ciclo" de esta manera podemos armar el cuadro de figura \ref{fig:CTS}\\[2ex]
		Este diagrama muestra los cambios que deben ocurrir según los tiempos del timer dentro del modulo, al llegar el tiempo final saca una bandera indicando el final.\\ [2ex]
		\begin{figure}[htbp]
			\centering
			\includegraphics[height=9cm, width=16cm]{img/JerarquiaRTC.jpg}
			\caption[3erNivel]{jerarquía de la RTC.}
			\label{fig:Jrtc}
		\end{figure}
		\begin{figure}[htbp]
			\centering
			\includegraphics[height=9cm, width=16cm]{img/diagramatiempoescritura.jpg}
			\caption[3erNivel]{Diagrama de tiempos completo del ciclo de escritura.}
			\label{fig:DTE}
		\end{figure}
		\begin{figure}[htbp]
			\centering
			\includegraphics[height=9cm, width=16cm]{img/diagramatiempolectura.jpg}
			\caption[3erNivel]{Diagrama de tiempos completo del ciclo de lectura.}
			\label{fig:DTL}
		\end{figure}
		\begin{figure}[htbp]
			\centering
			\includegraphics[height=9cm, width=16cm]{img/cuadrotiemposalida.jpg}
			\caption[3erNivel]{cuadro de tiempos del control de salida.}
			\label{fig:CTS}
		\end{figure}
		\subsubsection{nivel 1 control RTC}
		Para este nivel se requiere la entrada y salida de datos al registro de memoria de coneccion y tiene las salidas necesarias para controlar la RTC, esto se nota en la figura \ref{fig:nivel1RTC}.\\[2ex]
		\begin{figure}[htbp]
			\centering
			\includegraphics[height=9cm, width=16cm]{img/nivel1_RTC.jpg}
			\caption[3erNivel]{nivel 1 del RTC}
			\label{fig:nivel1RTC}
		\end{figure}
		\subsubsection{nivel 2 RTC}
		Esta etapa posee 4 bloques principales uno que controla la comunicación de la maquina principal de control y el bloque de la RTC. Esto se muestra en la figura \ref{fig:diagramaCRTC} en este se ven los caminos posibles a tomar. Ya sea escritura y lectura y sus respectivos tiempos de espera en la escritura de la RTC.
		
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=16cm]{img/DiagramaControlRTC.png}
			\caption{diagrama de la maquina de control de la RTC}
			\label{fig:diagramaCRTC}
		\end{figure}
		Para esta maquina exiten 2 camino que se pueden tomar, dependiendo de si se va a escribir o leer en la RTC, ademas de tener un ciclo de espera de la lectura o escritura en la RTC. Y tiene 2 modos de lectura uno por si se va a leer la RTC o la memoria del bloque.
		Siguiendo la jerarquía, existen 2 maquinas, escritura y lectura, estas respetan los flujos de la figura \ref{fig:FML} y \ref{fig:FME}, estas tienen las entradas de datos y dirección y la señal r y w respectivamente y tiene solo una salida de datos y r y w de esta manera las maquina controla que dato sale, si la direccion y o el dato, ademas tiene el bit de ciclo que determina si esta en el ciclo de escritura o lectura, como se nota en los flujos, el bit de ciclo no depende de la maquina, sino de la parte del programa donde esta se encuentre.\\[2ex]
		Por ultimo el control de salida responde al cuadro de la figura \ref{fig:CTS} a este le entra, el bit de activación que sale de la maquina de escritura o lectura, y entran los datos del ciclo y dato que salen dependiendo del tiempo; internamente este tiene un timer, con el fin de llevar el tiempo desde la activación, y dependiendo del tiempo que transcurre genera los cambios de la figura \ref{fig:CTS}. \\[2ex]
		\begin{figure}[htbp]
			\centering
			\includegraphics[height=9cm, width=16cm]{img/FlujoLec.jpg}
			\caption[3erNivel]{flujo de datos de la maquina de lectura}
			\label{fig:FML}
		\end{figure}
		\begin{figure}[htbp]
			\centering
			\includegraphics[height=9cm, width=16cm]{img/FlujoEsc.jpg}
			\caption[3erNivel]{flujo de datos de la maquina de Escritura}
			\label{fig:FME}
		\end{figure}
		\subsection{control principal}
		Una de las ideas principales del proyecto es controlar todo el sistema con una sola maquina realizada por un microprocesador.
		Para esta efecto se buscaron crear 5 ciclos, como se muestra de la figura \ref{fig:Cicloprincipal}, donde el primer ciclo es el de inicializacion {falta diseño}.\\
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=4cm]{img/Diagrama De Flujo Princiapal.png}
			\caption{Diagrama de flujo principal}
			\label{fig:Cicloprincipal}
		\end{figure}
		Después de este un ciclo de teclado, como se muestra en la figura \ref{fig:Cicloteclado}, en este se usan los espacios de memoria y Id de la tabla \ref{Tabla_deco}, usando los espacios de los registros auxiliares se guardan valores para generar ciclos como se muestra en el diagrama de flujo.\\
		Este flujo tiene 3 etapas principales, una donde guarda el valor del registro que desea cambiar y el valor del teclado. Luego se generan los cambios en la RTC, los procesos de arriba y abajo se hacen automáticamente y una vez que se hace un comit se escribe en la dirección y el dato que ingresaron previamente, el ultimo proceso es activar o desactivar el irq.\\
		Después de este proceso sigue el ciclo de la RTC como se muestra en la figura \ref{fig:CicloRTC}, este genera ciclos donde activa la lectura en la RTC, y espera a que el dato este estable para poder leerlo.\\
		Después de este proceso el sistema espera a que la VGA le solicite los datos luego este pasa al proceso de VGA como se muestra en la figura \ref{fig:CicloVGA}, este proceso se parece mucho al de escritura, donde se crea un ciclo donde se recorren todas las direcciones de escritura con la ayuda de un auxiliar y con ayuda del deco se determina el valor de dirección donde se guarda en la VGA.\\ 
		Por facilidad se uso la misma dirección en la memoria de regitros que en el id.\\[2ex]
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=16cm]{img/digrama de teclado irq.png}
			\caption{Diagrama de flujo principal}
			\label{fig:Cicloteclado}
		\end{figure}
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=10cm]{img/digrama de flujo RTC.png}
			\caption{Diagrama de flujo principal}
			\label{fig:CicloRTC}
		\end{figure}
		\begin{figure}[hbtp]
			\centering
			\includegraphics[width=10cm]{img/digrama de flujo VGA.png}
			\caption{Diagrama de flujo principal}
			\label{fig:CicloVGA}
		\end{figure}
		\begin{table}[]
			\centering
			\caption{resumen del Deco}
			\label{Tabla_deco}
			\begin{tabular}{lll}
				Id	& CS & ADD  \\
				1   & status 0 & 00 \\
				2   & status 1 & 01\\
				3   & status 2 & 02\\
				4   & comit & F0\\
				5	& teclado &  \\
				6	& teclado &  \\
				7	& teclado &  \\
				14	& sonido &  \\
				17	& RTC &  d33\\
				18	& RTC &  d34\\
				19	& RTC &  d35\\
				20	& RTC &  d36\\
				21	& RTC &  d37\\
				22	& RTC &  d38\\
				23	& RTC &  h41\\
				24	& RTC &  h42\\
				25	& RTC &  h43\\
				26	& RTC &  \\
				27	& RTC &  \\
				28	& RTC &  \\
				29	& RTC &  \\
				33	& AUX &  \\
				34	& AUX &  \\
				35	& AUX &  \\
				36	& AUX &  \\
				40	& VGA &  Direccion \\
				41	& VGA &  Dato\\
				42	& VGA &  Cursor3\\
				43	& VGA &  4\\
				44	& VGA &  5\\
				45	& VGA &  6\\
				46	& VGA &  7\\
				47	& VGA &  8\\
				48	& VGA &  9\\
				49	& VGA &  10\\
				50	& VGA &  11
			\end{tabular}
		\end{table}
		
		
		\section{Datos y resultados}
		\subsection{Simulaciones}
		Para el diseño del controlador VGA, se tenía que verificar el funcionamiento de la misma con respecto a los datos consultados a la memoria de registros de la RTC. Para ello, se ha realizado una simulación para verificar la funcionalidad del controlador VGA. Para este caso, la simulación de comprobación consta de dos partes importantes: la simulación en ISim y la traducción de los datos brindados para graficarlos en un script de Matlab.\\[2ex]
		Previo a simular, se tomará el punto de decenas en el día, que se encuentra en el punto en Y 130, de acuerdo con la imagen  \ref{fig:punteros}. Seguidamente, se verificará el cambio en el script de Matlab en comparativa con los datos que ingresaron e la figura \ref{fig:matlab}. \\[2ex]
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[height=12cm]{img/Punteros.png}
			\caption[3erNivel]{Punteros de memoria}
			\label{fig:PunterosVGA}
		\end{figure}
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[width=16cm]{img/SimVGA1.PNG}
			\caption[3erNivel]{Transiciones de datos.}
			\label{fig:SimVGA1}
		\end{figure}
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[width=16cm]{img/SimVGA2.PNG}
			\caption[3erNivel]{Tiempo de pulso HSync - Se cumple}
			\label{fig:SimVGA2}
		\end{figure}
		
			\begin{figure}[htbp]
				\centering
				\includegraphics[width=16cm]{img/SimVGA3.PNG}
				\caption[3erNivel]{Tiempos en HSync - Porches}
				\label{fig:SimVGA3}
			\end{figure}
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[width=16cm]{img/SimVGA4.PNG}
			\caption[3erNivel]{Tiempos en HSync en general}
			\label{fig:SimVGA4}
		\end{figure}
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[width=16cm]{img/SimVGA5.PNG}
			\caption[3erNivel]{Tiempos en VSync}
			\label{fig:SimVGA5}
		\end{figure}
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[width=16cm]{img/matlab.png}
			\caption[3erNivel]{Tiempos en HSync en general}
			\label{fig:matlab}
		\end{figure}
			
		\newpage
		
		Para el teclado, se ha desarrollado un testbench para poner a prueba la funcionalidad del Controlador de Teclado de forma completa, con emulación de presión de tecla. Refiérase a la figura \ref{fig:simkb1}
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[width=16cm]{img/simkb1_1.png}
			\caption[3erNivel]{Simulación del teclado}
			\label{fig:simkb1}
		\end{figure}
		
		En esta simulación, es posible apreciar los cambios en los registros Address, Data y Commit, que corresponden a los tres posibles registros que puede leer el picoblaze y seleccionarlos mediante el PortID. Además, el Keyboard\_Output puede desplegar un reinicio a cero después de la activación del ReadStrobe.
		
		\subsection{Mediciones}
		Es importante considerar el consumo de potencia de la implementación del diseño en la FPGA y el área ocupada dentro del Artix7, chip de FPGA que trae integrada la FPGA Nexys 4. En la Tabla \ref{tab:consumo} es posible observar algunos parámetros de consumo de potencia (obtenidos por medio del XPower Analizer) y los recursos brindados por la conclusión de la síntesis: \\[2ex]
		
		\begin{table}[htb]
			\centering
			\caption{Consumo de recursos de la FPGA}
			\begin{tabular}{c|c}
				Recurso & Consumo \\
				\hline
				\hline
				Potencia & 194mW \\
				Slices ocupadas & 1\% \\
				Registros & < 1\% \\
				IO & 22\% \\
				LUTs lógicos & 1\% \\
				LUT FF & 1306\\ 
				DSP48E1 & 1\% \\
				Reloj Máximo & 98.739MHz \\
				\end{tabular}
				\label{tab:consumo}
				\end{table}
		\section{Análisis de datos y resultados}
		
		
		\section{Hoja de datos de unidades desarrolladas}
		
		
		\section{Conclusiones y recomendaciones}
		\subsection{Conclusiones}
		
		
		\subsection{Recomendaciones}
		
		\section{Bibliografía}
		[3]"Nexys4-DDR Keyboard Demo [Reference.Digilentinc]", \textit{Reference.digilentinc.com} , 2016. [Online]. Available: https://reference.digilentinc.com/learn/programmable-logic/tutorials/nexys-4-ddr-keyboard-demo/start. [Accessed: 12-Oct-2016].
	\end{document}